using System;

namespace Kits.DevlpKit.Helpers
{
    /// <summary>
    /// Marshal ???????????
    /// </summary>
    public static class MarshalHelper
    {
        private const int m_BlockSize = 1024 * 4;
        private static IntPtr m_CachedHGlobalPtr = IntPtr.Zero;
        private static int m_CachedHGlobalSize = 0;

        /// <summary>
        /// ??????????????????????????????????
        /// </summary>
        public static int CachedHGlobalSize
        {
            get
            {
                return m_CachedHGlobalSize;
            }
        }

        /// <summary>
        /// ???????????????????????????????????
        /// </summary>
        /// <param name="ensureSize">??????????????????????????????</param>
        public static void EnsureCachedHGlobalSize(int ensureSize)
        {
            if (ensureSize < 0)
            {
                //throw new GameFrameworkException("Ensure size is invalid.");
                return;
            }

            if (m_CachedHGlobalPtr == IntPtr.Zero || m_CachedHGlobalSize < ensureSize)
            {
                FreeCachedHGlobal();
                int size = (ensureSize - 1 + m_BlockSize) / m_BlockSize * m_BlockSize;
                m_CachedHGlobalPtr = System.Runtime.InteropServices.Marshal.AllocHGlobal(size);
                m_CachedHGlobalSize = size;
            }
        }

        /// <summary>
        /// ????????????????????????????
        /// </summary>
        public static void FreeCachedHGlobal()
        {
            if (m_CachedHGlobalPtr != IntPtr.Zero)
            {
                System.Runtime.InteropServices.Marshal.FreeHGlobal(m_CachedHGlobalPtr);
                m_CachedHGlobalPtr = IntPtr.Zero;
                m_CachedHGlobalSize = 0;
            }
        }

        /// <summary>
        /// ????????????????????????
        /// </summary>
        /// <typeparam name="T">???????????????</typeparam>
        /// <param name="structure">?????????</param>
        /// <returns>???????????????????</returns>
        public static byte[] StructureToBytes<T>(T structure)
        {
            return StructureToBytes(structure, System.Runtime.InteropServices.Marshal.SizeOf(typeof(T)));
        }

        /// <summary>
        /// ????????????????????????
        /// </summary>
        /// <typeparam name="T">???????????????</typeparam>
        /// <param name="structure">?????????</param>
        /// <param name="structureSize">??????????????</param>
        /// <returns>???????????????????</returns>
        internal static byte[] StructureToBytes<T>(T structure, int structureSize)
        {
            if (structureSize < 0)
            {
                //throw new GameFrameworkException("Structure size is invalid.");
                return null;
            }

            EnsureCachedHGlobalSize(structureSize);
            System.Runtime.InteropServices.Marshal.StructureToPtr(structure, m_CachedHGlobalPtr, true);
            byte[] result = new byte[structureSize];
            System.Runtime.InteropServices.Marshal.Copy(m_CachedHGlobalPtr, result, 0, structureSize);
            return result;
        }

        /// <summary>
        /// ????????????????????????
        /// </summary>
        /// <typeparam name="T">???????????????</typeparam>
        /// <param name="structure">?????????</param>
        /// <param name="result">???????????????????</param>
        public static void StructureToBytes<T>(T structure, byte[] result)
        {
            StructureToBytes(structure, System.Runtime.InteropServices.Marshal.SizeOf(typeof(T)), result, 0);
        }

        /// <summary>
        /// ????????????????????????
        /// </summary>
        /// <typeparam name="T">???????????????</typeparam>
        /// <param name="structure">?????????</param>
        /// <param name="structureSize">??????????????</param>
        /// <param name="result">???????????????????</param>
        internal static void StructureToBytes<T>(T structure, int structureSize, byte[] result)
        {
            StructureToBytes(structure, structureSize, result, 0);
        }

        /// <summary>
        /// ????????????????????????
        /// </summary>
        /// <typeparam name="T">???????????????</typeparam>
        /// <param name="structure">?????????</param>
        /// <param name="result">???????????????????</param>
        /// <param name="startIndex">???????????????????????????</param>
        public static void StructureToBytes<T>(T structure, byte[] result, int startIndex)
        {
            StructureToBytes(structure, System.Runtime.InteropServices.Marshal.SizeOf(typeof(T)), result, startIndex);
        }

        /// <summary>
        /// ????????????????????????
        /// </summary>
        /// <typeparam name="T">???????????????</typeparam>
        /// <param name="structure">?????????</param>
        /// <param name="structureSize">??????????????</param>
        /// <param name="result">???????????????????</param>
        /// <param name="startIndex">???????????????????????????</param>
        internal static void StructureToBytes<T>(T structure, int structureSize, byte[] result, int startIndex)
        {
            if (structureSize < 0)
            {
                //throw new GameFrameworkException("Structure size is invalid.");
                return;
            }

            if (result == null)
            {
                //throw new GameFrameworkException("Result is invalid.");
                return;
            }

            if (startIndex < 0)
            {
                //throw new GameFrameworkException("Start index is invalid.");
                return;
            }

            if (startIndex + structureSize > result.Length)
            {
                //throw new GameFrameworkException("Result length is not enough.");
                return;
            }

            EnsureCachedHGlobalSize(structureSize);
            System.Runtime.InteropServices.Marshal.StructureToPtr(structure, m_CachedHGlobalPtr, true);
            System.Runtime.InteropServices.Marshal.Copy(m_CachedHGlobalPtr, result, startIndex, structureSize);
        }

        /// <summary>
        /// ??????????????????????
        /// </summary>
        /// <typeparam name="T">???????????????</typeparam>
        /// <param name="buffer">???????????????</param>
        /// <returns>?????????????</returns>
        public static T BytesToStructure<T>(byte[] buffer)
        {
            return BytesToStructure<T>(System.Runtime.InteropServices.Marshal.SizeOf(typeof(T)), buffer, 0);
        }

        /// <summary>
        /// ??????????????????????
        /// </summary>
        /// <typeparam name="T">???????????????</typeparam>
        /// <param name="buffer">???????????????</param>
        /// <param name="startIndex">????????????????????????</param>
        /// <returns>?????????????</returns>
        public static T BytesToStructure<T>(byte[] buffer, int startIndex)
        {
            return BytesToStructure<T>(System.Runtime.InteropServices.Marshal.SizeOf(typeof(T)), buffer, startIndex);
        }

        /// <summary>
        /// ??????????????????????
        /// </summary>
        /// <typeparam name="T">???????????????</typeparam>
        /// <param name="structureSize">??????????????</param>
        /// <param name="buffer">???????????????</param>
        /// <returns>?????????????</returns>
        internal static T BytesToStructure<T>(int structureSize, byte[] buffer)
        {
            return BytesToStructure<T>(structureSize, buffer, 0);
        }

        /// <summary>
        /// ??????????????????????
        /// </summary>
        /// <typeparam name="T">???????????????</typeparam>
        /// <param name="structureSize">??????????????</param>
        /// <param name="buffer">???????????????</param>
        /// <param name="startIndex">????????????????????????</param>
        /// <returns>?????????????</returns>
        internal static T BytesToStructure<T>(int structureSize, byte[] buffer, int startIndex)
        {
            if (structureSize < 0)
            {
                //throw new GameFrameworkException("Structure size is invalid.");
                return default(T);
            }

            if (buffer == null)
            {
                //throw new GameFrameworkException("Buffer is invalid.");
                return default(T);
            }

            if (startIndex < 0)
            {
                //throw new GameFrameworkException("Start index is invalid.");
                return default(T);
            }

            if (startIndex + structureSize > buffer.Length)
            {
                //throw new GameFrameworkException("Buffer length is not enough.");
                return default(T);
            }

            EnsureCachedHGlobalSize(structureSize);
            System.Runtime.InteropServices.Marshal.Copy(buffer, startIndex, m_CachedHGlobalPtr, structureSize);
            return (T)System.Runtime.InteropServices.Marshal.PtrToStructure(m_CachedHGlobalPtr, typeof(T));
        }
    }
}